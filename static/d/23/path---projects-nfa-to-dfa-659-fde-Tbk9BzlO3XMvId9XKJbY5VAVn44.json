{"data":{"markdownRemark":{"html":"<h3>Overview</h3>\n<p>I completed this project as part of my coursework for EECS 665, a Compilers course taught by Prasad Kulkarni. The program takes in a text representation of a <a href=\"https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton\">Nondeterministic Finite Automaton (NFA)</a> (read: a simple state machine) and converts it into a <a href=\"https://en.wikipedia.org/wiki/Deterministic_finite_automaton\">Deterministic Finite Automaton (DFA)</a>.</p>\n<p>Quick Finite State machine recap: they're simple machines capable of representing regular expressions, and some more complicated things, too. They look like this:</p>\n<p><img src=\"dfa-examples.png\"></p>\n<p>It's a series of states with different \"transition moves\" defined to travel in between them. States can also loop on themselves, like we see with the 'b' moves in the machines above.</p>\n<p>Notice the states with double rings: these are called the \"final states.\" They are a spot where the machine can stop producing/consuming input and safely stop.</p>\n<p>Now for the distinction: compare the machines above with this one:</p>\n<p><img src=\"nfa.png\"></p>\n<p>Notice the differences: there are some epsilon-transitions (or \"ε-transitions\"), and states can do multiple actions with the same symbol! This is the main distinction between DFAs and NFAs, as their name implies: <em>Deterministic</em> machines have at most one move defined for each alphabet symbol, and do not allow for ε-transitions. <em>Nondeterministic</em> machines on the other hand, can break both of those rules.</p>\n<p>An interesting fact, and the basis for this project, is that for every NFA that exists, a corresponding DFA can be created using the <a href=\"https://en.wikipedia.org/wiki/Powerset_construction\">subset construction algorithm</a>. Here it is in pseudocode:</p>\n<p><img src=\"subsetconst.png\"></p>\n<h3>Input and Output</h3>\n<p>The file takes in a text description of a NFA in table form:</p>\n<pre><code>Initial State: {1}\nFinal States: {11}\nTotal States: 11\nState   a   b   E\n1   {}  {}  {2,5}\n2   {3} {}  {}\n3   {}  {4} {}\n4   {}  {}  {8}\n5   {}  {6} {}\n6   {7} {}  {}\n7   {}  {}  {8}\n8   {}  {}  {9,11}\n9   {10}    {}  {}\n10  {}  {}  {9,11}\n11  {}  {}  {}\n</code></pre>\n<p>And it outputs the construction process and corresponding DFA in table form:</p>\n<pre><code>E-closure(IO) = {1,2,5}  = 0\n\nMark 0\n{1,2,5} --a--> {3}\nE-closure{3}  = {3}  = 1\n{1,2,5} --b--> {6}\nE-closure{6}  = {6}  = 2\n\nMark 1\n{3} --b--> {4}\nE-closure{4}  = {4,8,9,11}  = 3\n\nMark 2\n{6} --a--> {7}\nE-closure{7}  = {7,8,9,11}  = 4\n\nMark 3\n{4,8,9,11} --a--> {10}\nE-closure{10}  = {9,10,11}  = 5\n\nMark 4\n{7,8,9,11} --a--> {10}\nE-closure{10}  = {9,10,11}  = 5\n\nMark 5\n{9,10,11} --a--> {10}\nE-closure{10}  = {9,10,11}  = 5\n\nInitial State: {0}\nFinal State(s): {3,4,5}\nState      a        b\n0         {1}       {2}\n1         {}       {3}\n2         {4}       {}\n3         {5}       {}\n4         {5}       {}\n5         {5}       {}\n</code></pre>\n<h3>NFA and DFA Table Types</h3>\n<p>I spent a lot of time considering which data structures to use to contain the NFA and DFA representations. At its core, an NFA consists of a variable number of states. Each state has a series of moves defined on them over the \"input alphabet.\" And each move has a list of states associated with it.</p>\n<p>So if we put that all together, what does it look like? I call it a nested map:</p>\n<pre><code class=\"language-cpp\">typedef std::map&#x3C;int, std::map&#x3C;char, std::vector&#x3C;int>>> NFATableType;\n</code></pre>\n<p>The data structure maps an integer (a state) to another map (the moves), which is itself a map of a char (a character from input alphabet) to a vector of integers (the moves defined for that input symbol).</p>\n<p>The DFA Table was a little trickier, one that was a little too complicated to use maps and vectors alone. This is because:</p>\n<ul>\n<li>A single DFA state can actually be a representation of multiple NFA states</li>\n<li>In the subset construction algorithm, you need to keep track of whether or not a state has been \"marked\"</li>\n</ul>\n<p>For this reason, it made sense to use a map between integers and a DFA state struct:</p>\n<pre><code class=\"language-cpp\">struct DFAState {\n  bool marked;\n  std::vector&#x3C;int> states;\n  std::map&#x3C;char,int> moves;\n};\n\ntypedef std::map&#x3C;int, DFAState> DFATableType;\n</code></pre>\n<h3>Lessons Learned</h3>\n<ul>\n<li>Thinking about types is important.</li>\n<li>The C++ map and vector are workhorses. They are the core of this program (and I am thankful they both have thorough documentation).</li>\n<li>I did not take an efficient approach to my input file parsing function. It is monolithic; there are multiple areas that could be refactored or broken down into smaller functions.</li>\n<li>Incremental testing was key here. I started with file parsing, then the e-closure function, the move function, and finished with the subset construction function.</li>\n<li>The functions here do not work unless you <a href=\"http://stackoverflow.com/questions/19827119/c-argument-passing-passed-by-reference\">pass input arguments in by reference</a>. I spent more than a few minutes scratching my head why my eclosure and move functions kept failing when I was passing by value.</li>\n</ul>\n<p>The code for this project can be found <a href=\"https://github.com/e-nichols/NFA2DFA\">here.</a></p>","timeToRead":4,"tableOfContents":"<ul>\n<li><a href=\"/projects/nfa-to-dfa/#overview\">Overview</a></li>\n<li><a href=\"/projects/nfa-to-dfa/#input-and-output\">Input and Output</a></li>\n<li><a href=\"/projects/nfa-to-dfa/#nfa-and-dfa-table-types\">NFA and DFA Table Types</a></li>\n<li><a href=\"/projects/nfa-to-dfa/#lessons-learned\">Lessons Learned</a></li>\n</ul>","fields":{"tagSlugs":["/tags/c/","/tags/nfa-to-dfa/"]},"frontmatter":{"title":"NFA to DFA Conversion: C++ Implementation","tags":["C++","NFA to DFA"],"date":"2016-09-26T00:12:03.000Z","author":{"id":"Evan Nichols","bio":"I'm a software engineer in NYC who likes React, Node, GraphQL and other cool web technologies. I also like running and dogs."}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/projects/nfa-to-dfa/"}}